---
layout: post
title: Weekend Challenge #2
---
A double-barreled weekend challenge was issued to our cohort today.  
- Write our own method to replicate the inject method in Ruby.
- Write a take-away restaurant program that presents menus, takes orders and sends an SMS to customers to confirm delivery using [Twilio](https://www.twilio.com)  
I had a pretty relaxed day at Makers Academy, touching base with a lot of people I haven't had enough time to interact with, then in the afternoon I set to work rewriting inject... and quickly stalled!  This was going to be tough.  I continued in the evening and by about 11pm I had something that passed the tests and that I was somewhat ok with.  I'm not sure how long the take-away challenge is going to take me, but if I can squeeze in some more time around my social plans for the weekend then I'll have another go at it, but for now here's what I came up with:  
{% highlight ruby linenos %}
class Array
  def my_inject(arg = nil, arg_sym = nil)
    arg.nil? || arg.is_a?(Symbol) ? result = self[0] : result = arg
    if arg.nil? # inject without any args
      self[1..-1].each { |value| result = yield(result, value) }
      result
    else
      if arg.is_a?(Symbol) # inject with symbol
        self[1..-1].each { |value| result = result.send(arg, value) }
        result
      else
        if arg && arg_sym # inject with arg and symbol
          each { |value| result = result.send(arg_sym, value) }
          result
        else # inject with arg starting point
          each { |value| result = yield(result, value) }
          result
        end
      end
    end
  end
end
{% endhighlight %}
Join me after the break for a look at how my code evolved from terrible to satisfactory.  
<!--more-->  

So, what is inject?  According to [Ruby-doc](http://ruby-doc.org/core-2.2.1/Enumerable.html#method-i-inject):

>Inject combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator.
If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method.
If you do not explicitly specify an initial value for memo, then the first element of collection is used as the initial value of memo.

